%{ /* C Declarations and Definitions */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "A3_11.tab.h"
#include "parser.h" /* wasnt there in parser*/
extern int yylex(); // Generated by Flex
void yyerror(char *s);
#define NSYMS 20 /* max # of symbols */ 

// array of symbols
symboltable symtab[NSYMS];
// array of pointers to structure of objects
quad *qArray[NSYMS];
int quadPtr = 0;
%}


%union {                 
    int intval;
    struct symtab *symp;
    struct boo *buly;
}


%token CHAR ELSE FOR IF 
%token INT RETURN VOID TYPEDEF

%token <symp> IDENTIFIER

%token STRING_LIT
%token C_CONSTANT

%token <symp> I_CONSTANT

%token AND_OP
%token PTR_OP
%token OR_OP
%token LE_OP
%token GE_OP
%token EQ_OP
%token NE_OP
%define parse.error detailed
%type <symp> primary_expression
%type <symp> postfix_expression
%type <symp> unary_expression
%type <symp> multiplicative_expression
%type <symp> additive_expression
%type <intval> m
%type <buly> relational_expression
%type <buly> logical_AND_expression
%type <buly> equality_expression
%type <buly> logical_OR_expression
%start translation_unit

%%


//constant:
//C_CONSTANT |
//;

// EXPRESSIONS
primary_expression:
IDENTIFIER { $$ = $1;}| // Simple identifier  // Integer or character constant string-literal this wILLL BE PROBLEM
STRING_LIT |
I_CONSTANT { $$=gentemp(); char str[10];
sprintf(str, "%d", $1); emit_assign($$->name, str);} |
C_CONSTANT |
'(' expression ')'
;

postfix_expression: // Expressions with postfix operators. Left assoc. in C; non-assoc. here 
primary_expression {$$ = $1;}|
postfix_expression '[' expression ']' |// 1-D array access
postfix_expression '(' argument_expression_list_opt ')' |// Function invocation
postfix_expression PTR_OP IDENTIFIER
;

argument_expression_list_opt:
%empty |
argument_expression_list
;

argument_expression_list: 
assignment_expression |
argument_expression_list ',' assignment_expression
;

unary_operator:
'&'|'*' |'+' |'-' |'!';

unary_expression: 
postfix_expression {$$ = $1;}|
unary_operator unary_expression 
;

/*
create a binary quad

there  is a 

multiplicative expression can have a variable thingy
*/

multiplicative_expression: // Left associative operators 
unary_expression {$$ = $1;}|
multiplicative_expression '*' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MULT,$3->name);}|
multiplicative_expression '/' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, DIV,$3->name);}|
multiplicative_expression '%' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MOD,$3->name);}
;


additive_expression: // Left associative operators 
multiplicative_expression {$$ = $1;}|
additive_expression '+' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, PLUS,$3->name);}|
additive_expression '-' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MINUS,$3->name);}
;


/* a relational expression can have a an additive expression on
we can have the variables of the two things

if (x+1 < t1+t0 > t1)

t4 = x+1
t3 = t1+t0
if t4 <  t3 goto ...
goto ...
if t3 > t1 goto ...
goto ...


*/

relational_expression: // Left associative operators 
additive_expression |
additive_expression '<' additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char opt[] = "...";
    emit_jump_cond($1->name, LESS,$3->name, opt);
    printf("\tquadPtr is %d\n",quadPtr);
    
    //printf("%s\n",$1->name);
    $$->truelist =makelist(quadPtr);
    $$->falselist=makelist(quadPtr+1);
    //print_list($$->truelist);
    emit_jump(opt);
    print_list($$->falselist);
    }|
additive_expression '>' additive_expression {
    /* char opt[] = "...";
    emit_jump_cond($1->name, MORE,$3->name, opt);
    emit_jump(opt); */}|
additive_expression LE_OP additive_expression {
    /* char *opt = "...";/*
    //makelist($$->truelist,quadPtr);
    //makelist($$->falselist,quadPtr+1);*//*
    emit_jump_cond($1->name, LE,$3->name, opt);
    emit_jump(opt); */}|
additive_expression GE_OP additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    //char *opt = "...";
    //makelist($$->truelist,quadPtr);
    //makelist($$->falselist,quadPtr+1);
    /* emit_jump_cond($1->name, GE,$3->name, opt);
    emit_jump(opt); */}
;


m: %empty{$$ = quadPtr+1;printf("m= %d\n", $$);};

equality_expression: // Left associative operators 
relational_expression {$$ = $1;} |
equality_expression EQ_OP relational_expression |
equality_expression NE_OP relational_expression
;

logical_AND_expression: // Left associative operators 
equality_expression  {$$ = $1;} |
logical_AND_expression AND_OP m equality_expression 
{backpatch($1->truelist, $3);
print_list($1->truelist);
printf("PRINTING QUADTABLE\n%s\n",qArray[0]->result);
//print_quadtbl();
}
;

logical_OR_expression: // Left associative operators 
logical_AND_expression |
logical_OR_expression OR_OP logical_AND_expression
;

conditional_expression: // Right associative operator 
logical_OR_expression |
logical_OR_expression '?' expression ':' conditional_expression
;

assignment_expression: // Right associative operator 
conditional_expression |
unary_expression '=' assignment_expression
;

expression:
assignment_expression
;

//Declarations

declaration: // Simple identifier, 1-D array or function declaration of built-in type 
type_specifier init_declarator ';'
;

init_declarator:
declarator |// Simple identifier, 1-D array or function declaration
declarator '=' initializer
;

type_specifier: // Built-in types 
VOID |
CHAR |
INT
;

declarator:
pointer_opt direct_declarator
;

direct_declarator:
IDENTIFIER | // Simple identifier 
IDENTIFIER '[' I_CONSTANT ']' |
IDENTIFIER '(' parameter_list_opt ')' 
;


pointer: '*';

pointer_opt:
%empty |
pointer
;

parameter_list: 
parameter_declaration|
parameter_list ',' parameter_declaration
;

parameter_list_opt:
%empty |
parameter_list
;


parameter_declaration:
type_specifier pointer_opt identifier_opt
;

identifier_opt:
%empty |
IDENTIFIER
;

initializer:
assignment_expression;
// same as an expression



//initializer: assignment_expression;

// STATEMENT
statement:
compound_statement |// Multiple statements and / or nest block/s
expression_statement |// Any expression or null statements
selection_statement |// if or if_else
iteration_statement |// for
jump_statement
;

compound_statement:
'{' block_item_list_opt '}'
;

block_item_list_opt:
%empty |
block_item_list
;


block_item_list:
block_item |
block_item_list block_item
;

block_item:
declaration |
statement
;

expressionopt:
%empty |
expression
;

expression_statement:
expressionopt ';'
;

selection_statement:
IF '(' expression ')' statement |
IF '(' expression ')' statement ELSE statement
;


// fix this
iteration_statement:
FOR '(' expression_statement expression_statement expression ')' statement 
;

jump_statement:
RETURN expressionopt ';'
;

// idxwond

translation_unit: // Single source file containing main() 
function_definition |
declaration
;

function_definition:
type_specifier declarator declaration_list_opt  compound_statement 
;

declaration_list:
declaration |
declaration_list declaration
;

declaration_list_opt:
%empty |
declaration_list
;


%%
// return a symbol
struct symtab * symlook(char *s){
    char *p; 
    struct symtab *sp;
    // go through the symbol table array as long as the memory address of the current symbol table
    // is less than the memory address of the last symbol in the table
    for(sp = symtab; sp < &symtab[NSYMS]; sp++) { 
        /* is it already here? */
        if(sp->name && !strcmp(sp->name, s)){
            return sp;
        }
        /* is it free */
        // if there is available space then dump the name of the variable 
        if(!sp->name) {
            sp->name = strdup(s); 
            return sp;
        }
        /* otherwise continue to next */
    }
    yyerror("Too many symbols");
    exit(1);   /* cannot continue */ 
    
} /* symlook */

/* Generate temporary variable */ 
symboltable *gentemp() {
    static int c = 0; /* Temp counter */ 
    char str[10]; /* Temp name */
    /* Generate temp name */ 
    sprintf(str, "t%02d", c++);
    /* Add temporary to symtab */
    return symlook(str); 
}

void emit_bin(char *result, // Result
char *arg1, // Arg 1
opcodeType operator, // Operator
char *arg2) // Arg 2
{   
    quadPtr++;
    quad *qt = malloc(sizeof(quad));
    qt->result = result;
    qt->arg1 = arg1;
    qt->arg2 = arg2;
    qt->op = operator;
    qArray[quadPtr] = qt;
    /* Assignment with Binary operator */
    printf("\t%d: %s = %s %s %s\n",quadPtr,qArray[quadPtr]->result, qArray[quadPtr]->arg1, print_operator(qArray[quadPtr]->op), qArray[quadPtr]->arg2);
    //return qt;

}

void emit_jump(char *go) // Operator
{
    quadPtr++;
    quad *qt = malloc(sizeof(quad));
    qt->result = go;
    qt->op = JUMP;
    qArray[quadPtr] = qt;
    printf("\t%d: goto  %s\n", quadPtr, qArray[quadPtr]->result);
}

void emit_jump_cond(char *left, opcodeType operator,char *right, char *go) // Operator
{
/* Assignment with Unary operator */
    quadPtr++;
    quad *qt = malloc(sizeof(quad));
    qt->arg1 = left;
    qt->arg2 = right;
    qt->op = operator;
    qt->result = go;
    qArray[quadPtr] = qt;
    printf("\t%d: if %s %s %s goto  %s\n",quadPtr, qArray[quadPtr]->arg1, print_operator(qArray[quadPtr]->op), qArray[quadPtr]->arg2, qArray[quadPtr]->result);
    //return qt;
    
}

void emit_un(char *result, char *arg1, opcodeType operator) // Operator
{
/* Assignment with Unary operator */
    quadPtr++;
    quad *qt = malloc(sizeof(quad));
    qt->result = result;
    qt->arg1 = arg1;
    qt->op = operator;
    qArray[quadPtr] = qt;
    printf("\t%d: %s = %s %s\n",quadPtr, qArray[quadPtr]->result, print_operator(qArray[quadPtr]->op), qArray[quadPtr]->arg1);
    //return qt;
}




void emit_assign(char *result, char *arg1)
{
    /* Simple Assignment */
    quadPtr++;
    quad *qt = malloc(sizeof(quad));
    qt->result = result;
    qt->arg1 = arg1;
    qt->op = COPY;
    qArray[quadPtr] = qt;
    printf("\t%d: %s = %s\n",quadPtr,qArray[quadPtr]->result, qArray[quadPtr]->arg1);
    //return qt;
}
/*
 BOOLEAN FUNCTION
*/




// i is the current quad instruction
list* makelist(int i){
    // we are given the quad number and we need to create boolean struct
    //int arr[10];
    list *li= malloc(sizeof(list));
    node *gen = create(i);
    // gen is the address of the node
    li->head = gen;
    li->tail = gen;
    return li;
}

list * merge_lists(list *l1, list *l2) {
    list *li = malloc(sizeof(list));
    li->head = l1->head;
    l1->tail = l2->head;
    li->tail = l2->tail;
    free(l1);
    free(l2);

    return li;
}

node* create(int value) {
    node *genesis = malloc(sizeof(node));
    genesis->val= value;
    genesis->next = NULL;
    return genesis;
}

void backpatch(list * li, int m){
    printf("bacpack\n");
    node *temp = li->head;
    // only one node
    if (li->head==li->tail){
        int quadno = temp->val;
        printf("the quad number to be changed is %d\n",quadno);
        printf("current jump is %s\n",qArray[quadno]->result);
        //printf("\t%d: if %s %s %s goto  %s (backpatched)\n",quadno, qArray[quadno]->arg1, print_operator(qArray[quadno]->op), qArray[quadno]->arg2, qArray[quadno]->result);
    } else {
        while(temp!=li->tail){
            //printf("%d->",temp->val);
            int quadno = temp->val;
            qArray[quadno]->result = atoi(m);
            temp = temp->next;
            printf("\t%d: if %s %s %s goto  %s (backpatched)\n",quadno, qArray[quadno]->arg1, print_operator(qArray[quadno]->op), qArray[quadno]->arg2, qArray[quadno]->result);
        }
    }
}


void print_list(list * li){
    printf("printing list\n");
    node *temp = li->head;
    //printf("head %d->",temp->val);
    while(temp!=li->tail){
        printf("%d->",temp->val);
        temp = temp->next;
    }
    printf("%d\nlist has been printed\n",temp->val);
}


char* print_operator(opcodeType op) {
    switch (op) {
        case PLUS:
            return "+";
            break;
        case MINUS:
            //printf("-");
            return "-";
            break;
        case MULT:
            //printf("*");
            return "*";
            break;
        case DIV:
            //printf("/");
            return "/";
            break;
        case MOD:
            //printf("%");
            return "%";
            break;
        case LE:
            //printf("%");
            return "<=";
            break;
        case GE:
            //printf("%");
            return ">=";
            break;
        case OR:
            //printf("%");
            return "||";
            break;
        case AND:
            //printf("%");
            return "&&";
            break;
        case LESS:
            //printf("%");
            return "<";
            break;     
        case MORE:
            //printf("%");
            return ">";
            break;
        default:
            break;
    }
} 

// you will need to handle unary operators
void print_quadtbl() {
    int i =0;
    printf("\t%d: %s",qArray[i]->result);
    /* for(int i=0;i<NSYMS;i++){
        //quad *qp = qArray[i];
        if (PLUS<= qArray[i]->op <= DIV) {
            printf("\t%d: %s = %s %s %s\n",i,qArray[i]->result, qArray[i]->arg1, print_operator(qArray[i]->op), qArray[i]->arg2);
        } else if (DIV < qArray[i]->op <=GE) {
            printf("\t%d: if %s %s %s goto  %s\n",i, qArray[i]->arg1, print_operator(qArray[i]->op), qArray[i]->arg2, qArray[i]->result);
        } else if (qArray[i]->op == JUMP) {
            printf("\t%d: goto  %s\n", i, qArray[i]->result);
        } else if (qArray[i]->op == COPY) {
            printf("\t%d: %s = %s\n",i,qArray[i]->result, qArray[i]->arg1);
        } else {
            printf("\n");
        }
    } */
    
}