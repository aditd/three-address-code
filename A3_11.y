%{ /* C Declarations and Definitions */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "A3_11.tab.h"
#include "parser.h" /* wasnt there in parser*/
extern int yylex(); // Generated by Flex
void yyerror(char *s);
#define NSYMS 20 /* max # of symbols */ 
symboltable symtab[NSYMS];
// array of pointers to structure of objects
quad *qArray[NSYMS];
int quadPtr = 0;
%}


%union {                 
    int intval;
    struct symtab *symp;    /* 2 */
    boolean boo;
}


%token CHAR ELSE FOR IF 
%token INT RETURN VOID TYPEDEF

%token <symp> IDENTIFIER

%token STRING_LIT
%token C_CONSTANT

%token <symp> I_CONSTANT

%token AND_OP
%token PTR_OP
%token OR_OP
%token LE_OP
%token GE_OP
%token EQ_OP
%token NE_OP
%define parse.error detailed
%type <symp> primary_expression
%type <symp> postfix_expression
%type <symp> unary_expression
%type <symp> multiplicative_expression
%type <symp> additive_expression
%type <boo> relational_expression
%start translation_unit

%%


//constant:
//C_CONSTANT |
//;

// EXPRESSIONS
primary_expression:
IDENTIFIER { $$ = $1;}| // Simple identifier  // Integer or character constant string-literal this wILLL BE PROBLEM
STRING_LIT |
I_CONSTANT { $$->name = $1->name;} |
C_CONSTANT |
'(' expression ')'
;

postfix_expression: // Expressions with postfix operators. Left assoc. in C; non-assoc. here 
primary_expression {$$ = $1;}|
postfix_expression '[' expression ']' |// 1-D array access
postfix_expression '(' argument_expression_list_opt ')' |// Function invocation
postfix_expression PTR_OP IDENTIFIER
;

argument_expression_list_opt:
%empty |
argument_expression_list
;

argument_expression_list: 
assignment_expression |
argument_expression_list ',' assignment_expression
;

unary_operator:
'&'|'*' |'+' |'-' |'!';

unary_expression: 
postfix_expression {$$ = $1;}|
'+' unary_expression {$$ = gentemp(); 
emit_un($$->name, $2->name, PLUS);}|
'-' unary_expression {$$ = gentemp();
emit_un($$->name, $2->name, MINUS);}|
unary_operator unary_expression 
;

multiplicative_expression: // Left associative operators 
unary_expression {$$ = $1;}|
multiplicative_expression '*' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MULT,$3->name);}|
multiplicative_expression '/' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, DIV,$3->name);}|
multiplicative_expression '%' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MOD,$3->name);}
;

additive_expression: // Left associative operators 
multiplicative_expression {$$ = $1;}|
additive_expression '+' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, PLUS,$3->name);}|
additive_expression '-' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MINUS,$3->name);}
;



relational_expression: // Left associative operators 
additive_expression '<' additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char *opt = "...";
    $$.truelist = makelist(quadPtr);
    $$.falselist = makelist(quadPtr+1)
    emit_jump_cond($1->name, LESS,$3->name, opt)
    emit_jump($1->name);}|
additive_expression '>' additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char *opt = "...";
    $$.truelist = makelist(quadPtr);
    $$.falselist = makelist(quadPtr+1)
    emit_jump_cond($1->name, MORE,$3->name, opt)
    emit_jump($1->name);}|
additive_expression LE_OP additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char *opt = "...";
    $$.truelist = makelist(quadPtr);
    $$.falselist = makelist(quadPtr+1)
    emit_jump_cond($1->name, LE,$3->name, opt)
    emit_jump($1->name);}|
additive_expression GE_OP additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char *opt = "...";
    $$.truelist = makelist(quadPtr);
    $$.falselist = makelist(quadPtr+1)
    emit_jump_cond($1->name, GE,$3->name, opt)
    emit_jump($1->name);}
;


equality_expression: // Left associative operators 
relational_expression |
equality_expression EQ_OP relational_expression |
equality_expression NE_OP relational_expression
;

logical_AND_expression: // Left associative operators 
equality_expression |
logical_AND_expression AND_OP equality_expression
;

logical_OR_expression: // Left associative operators 
logical_AND_expression |
logical_OR_expression OR_OP logical_AND_expression
;

conditional_expression: // Right associative operator 
logical_OR_expression |
logical_OR_expression '?' expression ':' conditional_expression
;

assignment_expression: // Right associative operator 
conditional_expression |
unary_expression '=' assignment_expression
;

expression:
assignment_expression
;

//Declarations

declaration: // Simple identifier, 1-D array or function declaration of built-in type 
type_specifier init_declarator ';'
;

init_declarator:
declarator |// Simple identifier, 1-D array or function declaration
declarator '=' initializer
;

type_specifier: // Built-in types 
VOID |
CHAR |
INT
;

declarator:
pointer_opt direct_declarator
;

direct_declarator:
IDENTIFIER | // Simple identifier 
IDENTIFIER '[' I_CONSTANT ']' |
IDENTIFIER '(' parameter_list_opt ')' 
;


pointer: '*';

pointer_opt:
%empty |
pointer
;

parameter_list: 
parameter_declaration|
parameter_list ',' parameter_declaration
;

parameter_list_opt:
%empty |
parameter_list
;


parameter_declaration:
type_specifier pointer_opt identifier_opt
;

identifier_opt:
%empty |
IDENTIFIER
;

initializer:
assignment_expression;
// same as an expression



//initializer: assignment_expression;

// STATEMENT
statement:
compound_statement |// Multiple statements and / or nest block/s
expression_statement |// Any expression or null statements
selection_statement |// if or if_else
iteration_statement |// for
jump_statement
;

compound_statement:
'{' block_item_list_opt '}'
;

block_item_list_opt:
%empty |
block_item_list
;


block_item_list:
block_item |
block_item_list block_item
;

block_item:
declaration |
statement
;

expression_statement:
expressionopt ';'
;

selection_statement:
IF '(' expression ')' statement |
IF '(' expression ')' statement ELSE statement
;

expressionopt:
%empty |
expression
;

// fix this
iteration_statement:
FOR '(' expressionopt ';' expressionopt ';' expressionopt ')' statement 
;

jump_statement:
RETURN expressionopt ';'
;

// idxwond

translation_unit: // Single source file containing main() 
function_definition |
declaration
;

function_definition:
type_specifier declarator declaration_list_opt compound_statement 
;

declaration_list:
declaration |
declaration_list declaration
;

declaration_list_opt:
%empty |
declaration_list
;

%%
struct symtab * symlook(char *s){
    char *p; 
    struct symtab *sp;

    for(sp = symtab; sp < &symtab[NSYMS]; sp++) { 
        /* is it already here? */
        if(sp->name && !strcmp(sp->name, s)){
            return sp;
        }
        /* is it free */ 
        if(!sp->name) {
            sp->name = strdup(s); 
            return sp;
        }
        /* otherwise continue to next */
    }
    yyerror("Too many symbols");
    exit(1);   /* cannot continue */ 
    
} /* symlook */

/* Generate temporary variable */ 
symboltable *gentemp() {
    static int c = 0; /* Temp counter */ 
    char str[10]; /* Temp name */
    /* Generate temp name */ 
    sprintf(str, "t%02d", c++);
    /* Add temporary to symtab */
    return symlook(str); 
}

quad emit_bin(char *result, // Result
char *arg1, // Arg 1
opcodeType operator, // Operator
char *arg2) // Arg 2
{   
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.arg2 = arg2;
    qt.op = operator;
    qArray[quadPtr] = &qt;
    /* Assignment with Binary operator */
    printf("\t%d: %s = %s %c %s\n",quadPtr,qArray[quadPtr]->result, qArray[quadPtr]->arg1, print_operator(qArray[quadPtr]->op), qArray[quadPtr]->arg2);
    return qt;

}

quad emit_jump(char *go) // Operator
{
    quadPtr++;
    quad qt;
    qt.result = go;
    qt.op = JUMP;
    qArray[quadPtr] = &qt;
    return qt;
}

quad emit_jump_cond(char *left, opcodeType operator,char *right, char *go) // Operator
{
/* Assignment with Unary operator */
    quadPtr++;
    quad qt;
    qt.arg1 = left;
    qt.arg2 = right;
    qt.op = operator;
    qt.result = go;
    qArray[quadPtr] = &qt;
    printf("\t%d: if %s %c %s goto  %s\n",quadPtr, qt.arg1, print_operator(qt.op)  qt.result);
    return qt;
    
}

quad emit_un(char *result, char *arg1, opcodeType operator) // Operator
{
/* Assignment with Unary operator */
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.op = operator;
    qArray[quadPtr] = &qt;
    printf("\t%d: %s = %c %s\n",quadPtr, qt.result, print_operator(op), arg1);
    return qt;
}




quad emit_assign(char *result, char *arg1)
{
    /* Simple Assignment */
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.op = COPY;
    qArray[quadPtr] = &qt;
    printf("\t%d: %s = %s\n",quadPtr,qArray[quadPtr]->result, qArray[quadPtr]->arg1);
    return qt;
}

// i is the current quad instruction
int * makelist(int i){
    // we are given the quad number and we need to create boolean struct
    int arr[10];
    arr[0] = i;
    return arr;
}


void backpatch(int *lis, int i){
    // we get a list with dangling exits and a line number i
    // arg2 is where the jump location is kept
    for(int i=0;i++;i<10){
        // if the list is empty
        if(lis[i].Function() == 0) break;
        // get the
        // get the quadLoc that we need to change
        int quadLoc = lis[i];
        // change the jump location of the quad
        sprintf(qArray[quadLoc]->arg2, "%d", i);
    }
}

int * merge_lists(int *l1,int *l2) {
    // temp array
    int arr[10];
    int x=0;
    // go through the whole array and add stuff
    for(int i =0;i++;i<10){
        if(l1[i].Function() == 0) break;
        arr[x] = l1[i]
        x++;
    }
    for(int i =0;i++;i<10){
        if(l2[i].Function() == 0) break;
        arr[x] = l2[i]
        x++;
    }
    // return the merged array
    return arr;
}

char print_operator(opcodeType op) {
    switch (op) {
        case PLUS:
            return '+';
            break;
        case MINUS:
            //printf("-");
            return '-';
            break;
        case MULT:
            //printf("*");
            return '*';
            break;
        case DIV:
            //printf("/");
            return '/';
            break;
        case MOD:
            //printf("%");
            return '%';
            break;
        case LE:
            //printf("%");
            return '<=';
            break;
        case GE:
            //printf("%");
            return '>=';
            break;
        case OR:
            //printf("%");
            return '||';
            break;
        case AND:
            //printf("%");
            return '&&';
            break;
        case LESS:
            //printf("%");
            return '<';
            break;     
        case MORE:
            //printf("%");
            return '>';
            break;
        default:
            break
    }
} 
/*
void yyerror(char *s) { printf ("error %s\n", s);
}

int main() {
    yyparse(); 
}
*/