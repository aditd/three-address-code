%{ /* C Declarations and Definitions */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "A3_11.tab.h"
#include "parser.h" /* wasnt there in parser*/
extern int yylex(); // Generated by Flex
void yyerror(char *s);
#define NSYMS 20 /* max # of symbols */ 

// array of symbols
// symboltable symtab[NSYMS];
// array of pointers to structure of objects
extern quad *qArray[NSYMS];
extern int quadPtr;
%}


%union {                 
    int intval;
    struct symtab *symp;
    struct boo *buly;
}


%token CHAR ELSE FOR IF 
%token INT RETURN VOID TYPEDEF

%token <symp> IDENTIFIER

%token STRING_LIT
%token C_CONSTANT

%token <symp> I_CONSTANT

%token AND_OP
%token PTR_OP
%token OR_OP
%token LE_OP
%token GE_OP
%token EQ_OP
%token NE_OP
%define parse.error detailed
%type <symp> primary_expression
%type <symp> postfix_expression
%type <symp> unary_expression
%type <symp> multiplicative_expression
%type <symp> additive_expression
%type <intval> m
%type <buly> relational_expression
%type <buly> logical_AND_expression
%type <buly> equality_expression
%type <buly> logical_OR_expression
%start translation_unit

%%


//constant:
//C_CONSTANT |
//;

// EXPRESSIONS
primary_expression:
IDENTIFIER { $$ = $1;}| // Simple identifier  // Integer or character constant string-literal this wILLL BE PROBLEM
STRING_LIT |
I_CONSTANT { $$=gentemp(); char str[10];
sprintf(str, "%d", $1); emit_assign($$->name, str);} |
C_CONSTANT |
'(' expression ')'
;

postfix_expression: // Expressions with postfix operators. Left assoc. in C; non-assoc. here 
primary_expression {$$ = $1;}|
postfix_expression '[' expression ']' |// 1-D array access
postfix_expression '(' argument_expression_list_opt ')' |// Function invocation
postfix_expression PTR_OP IDENTIFIER
;

argument_expression_list_opt:
%empty |
argument_expression_list
;

argument_expression_list: 
assignment_expression |
argument_expression_list ',' assignment_expression
;

unary_operator:
'&'|'*' |'+' |'-' |'!';

unary_expression: 
postfix_expression {$$ = $1;}|
unary_operator unary_expression 
;

/*
create a binary quad

there  is a 

multiplicative expression can have a variable thingy
*/

multiplicative_expression: // Left associative operators 
unary_expression {$$ = $1;}|
multiplicative_expression '*' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MULT,$3->name);}|
multiplicative_expression '/' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, DIV,$3->name);}|
multiplicative_expression '%' unary_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MOD,$3->name);}
;


additive_expression: // Left associative operators 
multiplicative_expression {$$ = $1;}|
additive_expression '+' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, PLUS,$3->name);}|
additive_expression '-' multiplicative_expression {$$ = gentemp();
emit_bin($$->name, $1->name, MINUS,$3->name);}
;


/* a relational expression can have a an additive expression on
we can have the variables of the two things

if (x+1 < t1+t0 > t1)

t4 = x+1
t3 = t1+t0
if t4 <  t3 goto ...
goto ...
if t3 > t1 goto ...
goto ...


*/

relational_expression: // Left associative operators 
additive_expression |
additive_expression '<' additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    char opt[] = "...";
    emit_jump_cond($1->name, LESS,$3->name, opt);
    printf("\tquadPtr is %d\n",quadPtr);
    
    //printf("%s\n",$1->name);
    $$->truelist =makelist(quadPtr);
    $$->falselist=makelist(quadPtr+1);;
    //print_list($$->truelist);
    emit_jump(opt);
    //print_list($$->falselist);
    }|
additive_expression '>' additive_expression {
    /* char opt[] = "...";
    emit_jump_cond($1->name, MORE,$3->name, opt);
    emit_jump(opt); */}|
additive_expression LE_OP additive_expression {
    /* char *opt = "...";/*
    //makelist($$->truelist,quadPtr);
    //makelist($$->falselist,quadPtr+1);*//*
    emit_jump_cond($1->name, LE,$3->name, opt);
    emit_jump(opt); */}|
additive_expression GE_OP additive_expression {
    //char *x=$1->name;strcpy(x,"<");strcpy(x,$3->name);// // the relational expression is x  a<b or somethin like t00 < a
    //char *opt = "...";
    //makelist($$->truelist,quadPtr);
    //makelist($$->falselist,quadPtr+1);
    /* emit_jump_cond($1->name, GE,$3->name, opt);
    emit_jump(opt); */}
;


m: %empty{$$ = quadPtr+1;printf("m= %d\n", $$);};

equality_expression: // Left associative operators 
relational_expression {$$ = $1;} |
equality_expression EQ_OP relational_expression |
equality_expression NE_OP relational_expression
;

logical_AND_expression: // Left associative operators 
equality_expression  {$$ = $1;} |
logical_AND_expression AND_OP m equality_expression 
{backpatch($1->truelist, $3);
//print_list($1->truelist);
printf("PRINTING QUADTABLE\n%s\n",qArray[0]->result);
print_quadtbl();;
}
;

logical_OR_expression: // Left associative operators 
logical_AND_expression |
logical_OR_expression OR_OP logical_AND_expression
;

conditional_expression: // Right associative operator 
logical_OR_expression |
logical_OR_expression '?' expression ':' conditional_expression
;

assignment_expression: // Right associative operator 
conditional_expression |
unary_expression '=' assignment_expression
;

expression:
assignment_expression
;

//Declarations

declaration: // Simple identifier, 1-D array or function declaration of built-in type 
type_specifier init_declarator ';'
;

init_declarator:
declarator |// Simple identifier, 1-D array or function declaration
declarator '=' initializer
;

type_specifier: // Built-in types 
VOID |
CHAR |
INT
;

declarator:
pointer_opt direct_declarator
;

direct_declarator:
IDENTIFIER | // Simple identifier 
IDENTIFIER '[' I_CONSTANT ']' |
IDENTIFIER '(' parameter_list_opt ')' 
;


pointer: '*';

pointer_opt:
%empty |
pointer
;

parameter_list: 
parameter_declaration|
parameter_list ',' parameter_declaration
;

parameter_list_opt:
%empty |
parameter_list
;


parameter_declaration:
type_specifier pointer_opt identifier_opt
;

identifier_opt:
%empty |
IDENTIFIER
;

initializer:
assignment_expression;
// same as an expression



//initializer: assignment_expression;

// STATEMENT
statement:
compound_statement |// Multiple statements and / or nest block/s
expression_statement |// Any expression or null statements
selection_statement |// if or if_else
iteration_statement |// for
jump_statement
;

compound_statement:
'{' block_item_list_opt '}'
;

block_item_list_opt:
%empty |
block_item_list
;


block_item_list:
block_item |
block_item_list block_item
;

block_item:
declaration |
statement
;

expressionopt:
%empty |
expression
;

expression_statement:
expressionopt ';'
;

selection_statement:
IF '(' expression ')' statement |
IF '(' expression ')' statement ELSE statement
;


// fix this
iteration_statement:
FOR '(' expression_statement expression_statement expression ')' statement 
;

jump_statement:
RETURN expressionopt ';'
;

// idxwond

translation_unit: // Single source file containing main() 
function_definition |
declaration
;

function_definition:
type_specifier declarator declaration_list_opt  compound_statement 
;

declaration_list:
declaration |
declaration_list declaration
;

declaration_list_opt:
%empty |
declaration_list
;


%%
