%{
    /* C Declarations and Definitions */
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include "A3_11.tab.h"
    #include "parser.h" /* wasnt there in parser*/

    extern int yylex(); // Generated by Flex
    void yyerror(char *s);

    #define NSYMS 20 /* max # of symbols */
    symboltable symtab[NSYMS];
    quad *qArray[NSYMS];
    int quadPtr = 0;
%}

%union {
    int intval;
    struct symtab *symp;    /* 2 */
}

%token CHAR ELSE FOR IF
%token INT RETURN VOID TYPEDEF
%token STRING_LIT
%token C_CONSTANT
%token AND_OP
%token PTR_OP
%token OR_OP
%token LE_OP
%token GE_OP
%token EQ_OP
%token NE_OP
%token <symp> IDENTIFIER
%token <symp> I_CONSTANT

%define parse.error detailed

%type <symp> primary_expression
%type <symp> postfix_expression
%type <symp> unary_expression
%type <symp> multiplicative_expression
%type <symp> additive_expression

%start translation_unit
%%

// EXPRESSIONS
primary_expression:   IDENTIFIER { $$ = $1; } // Integer or character constant string-literal this wILLL BE PROBLEM
                    | STRING_LIT
                    | I_CONSTANT { $$->name = $1->name; }
                    | C_CONSTANT
                    | '(' expression ')'
                    ;

// Expressions with postfix operators. Left assoc. in C; non-assoc. here
postfix_expression:   primary_expression { $$ = $1; }
                    | postfix_expression '[' expression ']' // 1-D array access
                    | postfix_expression '(' argument_expression_list_opt ')' // function invocation
                    | postfix_expression PTR_OP IDENTIFIER
                    ;

argument_expression_list_opt:     %empty
                                | argument_expression_list
                                ;

argument_expression_list:     assignment_expression
                            | argument_expression_list ',' assignment_expression
                            ;

unary_operator:  '&'
                | '*'
                | '+'
                | '-'
                | '!'
                ;

unary_expression:     postfix_expression { $$ = $1; }
                    | '+' unary_expression { $$ = gentemp();
                        emit_un($$->name, $2->name, PLUS); }
                    | '-' unary_expression { $$ = gentemp();
                        emit_un($$->name, $2->name, MINUS); }
                    | unary_operator unary_expression
                    ;

// Left associative operators
multiplicative_expression:    unary_expression { $$ = $1; }
                            | multiplicative_expression '*' unary_expression { $$ = gentemp();
                                emit_bin($$->name, $1->name, MULT,$3->name); }
                            | multiplicative_expression '/' unary_expression { $$ = gentemp();
                                emit_bin($$->name, $1->name, DIV,$3->name); }
                            | multiplicative_expression '%' unary_expression { $$ = gentemp();
                                emit_bin($$->name, $1->name, MOD,$3->name); }
                            ;

// Left associative operators
additive_expression:  multiplicative_expression { $$ = $1; }
                    | additive_expression '+' multiplicative_expression { $$ = gentemp();
                        emit_bin($$->name, $1->name, PLUS,$3->name); }
                    | additive_expression '-' multiplicative_expression { $$ = gentemp();
                        emit_bin($$->name, $1->name, MINUS,$3->name); }
                    ;

// Left associative operators
relational_expression:    additive_expression
                        | relational_expression '<' additive_expression
                        | relational_expression '>' additive_expression
                        | relational_expression LE_OP additive_expression
                        | relational_expression GE_OP additive_expression
                        ;

// Left associative operators
equality_expression:  relational_expression
                    | equality_expression EQ_OP relational_expression
                    | equality_expression NE_OP relational_expression
                    ;

// Left associative operators
logical_AND_expression:   equality_expression
                        | logical_AND_expression AND_OP equality_expression
                        ;

// Left associative operators
logical_OR_expression:    logical_AND_expression
                        | logical_OR_expression OR_OP logical_AND_expression
                        ;

// Right associative operator
conditional_expression:   logical_OR_expression
                        | logical_OR_expression '?' expression ':' conditional_expression
                        ;

// Right associative operator
assignment_expression:    conditional_expression
                        | unary_expression '=' assignment_expression
                        ;

expression:   assignment_expression
            ;

// DECLARATIONS
// Simple identifier, 1-D array or function declaration of built-in type
declaration:  type_specifier init_declarator ';'
            ;

init_declarator:  declarator // Simple identifier, 1-D array or function declaration
                | declarator '=' initializer
                ;

// Built-in types
type_specifier:   VOID
                | CHAR
                | INT
                ;

declarator:   pointer_opt direct_declarator
            ;

direct_declarator:    IDENTIFIER // Simple identifier
                    | IDENTIFIER '[' I_CONSTANT ']'
                    | IDENTIFIER '(' parameter_list_opt ')'
                    ;


pointer:  '*'
        ;

pointer_opt:  %empty
            | pointer
            ;

parameter_list:   parameter_declaration
                | parameter_list ',' parameter_declaration
                ;

parameter_list_opt:   %empty
                    | parameter_list ;


parameter_declaration:    type_specifier pointer_opt identifier_opt
                        ;

identifier_opt:   %empty
                | IDENTIFIER
                ;

initializer:  assignment_expression // same as an expression
            ;

// STATEMENT
statement:    compound_statement // Multiple statements and / or nest block/s
            | expression_statement // Any expression or null statements
            | selection_statement // if or if_else
            | iteration_statement // for
            | jump_statement
            ;

compound_statement:   '{' block_item_list_opt '}'
                    ;

block_item_list_opt:  %empty
                    | block_item_list
                    ;

block_item_list:  block_item
                | block_item_list block_item
                ;

block_item:   declaration
            | statement
            ;

expression_statement:     expressionopt ';'
                        ;

selection_statement:  IF '(' expression ')' statement
                    | IF '(' expression ')' statement ELSE statement
                    ;

expressionopt:    %empty
                | expression
                ;

// fix this
iteration_statement:  FOR '(' expressionopt ';' expressionopt ';' expressionopt ')' statement
                    ;

jump_statement:   RETURN expressionopt ';'
                ;

// idxwond
// Single source file containing main()
translation_unit:     function_definition
                    | declaration
                    ;

function_definition:  type_specifier declarator declaration_list_opt compound_statement
                    ;

declaration_list:     declaration
                    | declaration_list declaration
                    ;

declaration_list_opt:     %empty
                        | declaration_list
                        ;
%%

// check if given variable name exists, if not then add it and return pointer to the variable
struct symtab * symlook(char *s) {
    char *p;
    struct symtab *sp;

    for(sp = symtab; sp < &symtab[NSYMS]; sp++) {
        // check if current element has a non empty name and the name is same as s
        if(sp->name && !strcmp(sp->name, s)){
            return sp;
        }
        // if current element is empty, then add the name to it
        if(!sp->name) {
            sp->name = strdup(s);
            return sp;
        }
        // find the next empty element or matching element
    }

    yyerror("roo many symbols");
    exit(1);   // reached max number of variables that can be handled
}

// generate temporary variable and return pointer to it
symboltable *gentemp() {
    static int c = 0; /* Temp counter */
    char str[10]; /* Temp name */
    /* Generate temp name */
    sprintf(str, "t%02d", c++);
    /* Add temporary to symtab */
    return symlook(str);
}

quad emit_bin(char *result, char *arg1, opcodeType operator, char *arg2){
    /* Assignment with Binary operator */
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.arg2 = arg2;
    qt.op = operator;
    qt.type = BINARY;

    printf("\t%d: %s = %s %c %s\n", quadPtr, result, arg1, 'o', arg2);
    return qt;
}

quad emit_un(char *result, char *arg1,opcodeType operator){
    /* Assignment with Unary operator */
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.op = operator;
    qt.type = UNARY;

    printf("\t%d: %s = %c %s\n",quadPtr, qt.result, 'o', arg1);
    return qt;
}

quad emit_assign(char *result, char *arg1){
    /* Simple Assignment */
    quadPtr++;
    quad qt;
    qt.result = result;
    qt.arg1 = arg1;
    qt.type = ASSIGN;

    printf("\t%d: %s = %s\n",quadPtr,result, arg1);
    return qt;
}
